"""Cisco vManage Event API Methods.
"""
import json
import time
from datetime import datetime, date, timezone

from vmanage.api.http_methods import HttpMethods
from vmanage.data.parse_methods import ParseMethods


class Event(object):
    """vManage Event  API

    Responsible for DELETE, GET, POST, PUT methods against vManage
    Event.

    """

    def __init__(self, session, host, port=443):
        """Initialize Event object with session parameters.

        Args:
            session (obj): Requests Session object
            host (str): hostname or IP address of vManage
            port (int): default HTTPS 443

        """

        self.session = session
        self.host = host
        self.port = port
        self.base_url = f"https://{self.host}:{self.port}/dataservice/"

    def get_event_list(
        self,
        time_range=1,
        from_timestamp=None,
        to_timestamp=None,
        component=None,
        event_name=None,
    ):
        """Obtain a list of specified device type

        Args:
            time_range (str): range of time to get events for (in hours)
            from_time (unix timestamp): timestamp of when to get events from (overrides time_range, if provided)
            to_time (unix timestamp): timestamp of when to get events through (defaults to now if from is specified; overrides time_range, if provided; ignored if no from_timestamp provided)
            component (str): filter events that were generated by this component type
            event_name (str): filter events of this name

        Returns:
            result (dict): All data associated with a response.
        """

        url = f"{self.base_url}event"
        payload = {
            "query": {
                "condition": "AND",
                "rules": [],
            },
            "size": 10000,
        }

        if time_range and not from_timestamp:
            payload["query"]["rules"].append(
                {
                    "value": [str(time_range)],
                    "field": "entry_time",
                    "type": "date",
                    "operator": "last_n_hours",
                }
            )

        if from_timestamp:
            from_timestamp = (
                from_timestamp.strftime("%Y-%m-%dT%H:%M:%S UTC")
                if isinstance(from_timestamp, date)
                else datetime.fromtimestamp(from_timestamp, tz=timezone.utc).strftime(
                    "%Y-%m-%dT%H:%M:%S UTC"
                )
            )
            if to_timestamp:
                to_timestamp = (
                    int(time.mktime(datetime.now(tz=timezone.utc).timetuple()))
                    if isinstance(to_timestamp, date)
                    else datetime.fromtimestamp(to_timestamp, tz=timezone.utc).strftime(
                        "%Y-%m-%dT%H:%M:%S UTC"
                    )
                )
            else:
                to_timestamp = datetime.now(tz=timezone.utc).strftime(
                    "%Y-%m-%dT%H:%M:%S UTC"
                )
            payload["query"]["rules"].append(
                {
                    "value": [
                        from_timestamp,
                        to_timestamp,
                    ],
                    "field": "entry_time",
                    "type": "date",
                    "operator": "between",
                }
            )

        if component:
            payload["query"]["rules"].append(
                {
                    "value": [component],
                    "field": "component",
                    "type": "string",
                    "operator": "in",
                }
            )

        if event_name:
            payload["query"]["rules"].append(
                {
                    "value": [event_name],
                    "field": "eventname",
                    "type": "string",
                    "operator": "in",
                }
            )

        response = HttpMethods(self.session, url).request(
            "POST",
            payload=json.dumps(payload),
        )
        result = ParseMethods.parse_data(response)
        return result
